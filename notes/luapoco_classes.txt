* DirectoryWatcher
----------------------------------------
1. There are events which require a Poco::Delegate() to be operator+='d
	onto the Event but the Delegate is dispatched from the thread 
	spawned by the DirectoryWatcher, so the FileEvent structure will 
	need to be copied to the Lua thread, then a syncronization method
	used to block the Delegate from returning until the Lua thread returns.
2. DirectoryWatcher can be constructed with a table of lua Functions that
	correspond to each event Delegate callback.

* NotificationCenter
----------------------------------------
PocoNote: In a multithreaded scenario, notifications are always delivered in 
	the thread in which the notification was posted, which may not be 
	the same thread in which an observer registered itself.
1. Lua doesn't have a concept of thread interruption, so Notifications 
	will need to be delivered to a lua state that is either blocked on a
	run() call and the callbacks are dispatched, or perhaps there would
	be a function that polls for new notifications.

* NotificationQueue
----------------------------------------
PocoNote 1: Special care must be taken when shutting down a queue with worker threads waiting for notifications. The recommended sequence to shut down and destroy the queue is to
	set a termination flag for every worker thread
	call the wakeUpAll() method
	join each worker thread
	destroy the notification queue.

PocoNote 2: How to tell worker threads they are done?
	1. Post a special QuitNotification for every worker thread;
	2. Set a (global) stop flag and use waitDequeueNotification() with a timeout;
	3. Use wakeUpAll(): every call to waitDequeueNotification() will immediately return null.

* TaskManager
----------------------------------------
1.  It makes sense to funnel NotificationCenter messages to the lua_State that owns the TaskManager
	object via a NotificationQueue.  That thread could then use the dequeue mechanism with a timeout or whatever
	to acquire notifications.
2.  Using the mechanism above, it would be possible to employ a run() method to dispatch to some callbacks in the
	owning lua_State, with some locking around the lua_State itself.
	
* Task
----------------------------------------
1. Task needs to have a userdata with protected side accessible interface 
	in order to check isCancelled/sleep, etc.  Userdata registered as self or 
	_self in the global environment of the new lua_State/native thread.
